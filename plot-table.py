import matplotlib.pyplot as plt
from matplotlib.gridspec import GridSpec
from matplotlib.ticker import FuncFormatter
import numpy as np
import scipy.stats as st
import os
import pdfkit
import sys
import pylab

# this needs to be changed with the directory name generated by the execute
# script
version = '20200122-153406-33fa79b5a6'

# default subdir to store/retrieve data (usually does not require any changes)
exec_log_dir = 'logs'
exec_plot_dir = 'plots_time'
stag_plot_dir = 'plots_stag'
comp_plot_dir = 'compare'
table_dir = 'tables'

resultdir = 'results-' + version


# The benchmark to be processed
benchmark = ['genome', 'intruder', 'kmeans', 'labyrinth', 'ssca2', 'vacation', 'yada']
# standard thread numbers
threads = ['1', '2', '4', '6', '8', '10', '12', '14', '16', '18']
# default TM configurations - the different configurations
tm = ['nvm_rtm-simple_lock', 'pstm_x86_64', 'nvphtm_pstm_nh_x86_64', 'nvphtm_pstm_x86_64']
tmlabel = ['NV-HTM', 'PSTM', 'PhTM*', 'NV-PhTM']




def millions(x, pos):
    'The two args are the value and tick position'
    return '%1.0fM' % (x * 1e-6)

# get all timestamp from filename in a list
def getTimestamp(filename):
    values=[]
    with open(filename) as f:
        for line in f:
            fields = line.strip().split()
            if fields and fields[0] == 'Time' and fields[1] == '=':
                values.append(float(fields[2]))

    return values






def get_mean_v(values):

    mean = -1
    std = -1
    # calculate the mean and standard deviation of the samples
    if values:
        n, min_max, mean, var, skew, kurt = st.describe(values)
        std=np.sqrt(var)

        ci = st.t.interval(0.95,len(values)-1,loc=mean,scale=std/np.sqrt(len(values)))

    diff = (ci[1]-ci[0])/2

    return mean, diff


def get_mean(filename):

    # find the lines with the time stamp
    values = getTimestamp(filename)

    return get_mean_v(values)







# this first compute the arithmetic mean, then normalizes
# the confidence interval is approximated by using the percentage relative to
# the arithmetic value
def get_mean_normal(filename, seq):

    values = getTimestamp(filename)

    m, s  = get_mean_v(values)

    normal = seq/m

    return normal, normal*(s/m)



# this simply calculates the arithmetic mean of rations (wrong?)
def get_mean_normal2(filename, seq):

    values=[]
    with open(filename) as f:
        for line in f:
            fields = line.strip().split()
            if fields and fields[0] == 'Time' and fields[1] == '=':
                values.append(seq/float(fields[2]))

    return get_mean_v(values)


# this computes the geometric mean of each ratio
# should work, but how to devise the confidence interval?
def get_mean_normal3(filename, seq):

    values=[]
    with open(filename) as f:
        for line in f:
            fields = line.strip().split()
            if fields and fields[0] == 'Time' and fields[1] == '=':
                values.append(seq/float(fields[2]))

    return st.gmean(values), 0


#
# Saves a txt file with the following format:
#
#  #level1[0]
#      mean(level2[0].level3[0]), ..., mean(level2[0].level3[k-1]
#      std(level2[0].level3[0]), ..., ...
#
#      mean(level2[m-1].level3[0]), ... mean(level2[m-1].level3[k-1]
#
#  #level1[1]
#
#     .
#     .
#  #level1[n-1]
#
#
#  outfilename - name of the file to be created
#  inprefix    - prefix of the input file names - complete filename is made of:
#       inprefix + '-' + level1[] + '-' + level2[] + '-' + level3[]
#
def save_data(outfilename, filedir, inprefix, level1, level2, level3):

    f = open(outfilename, 'wb')

    for ip in inprefix:

        for lvl1 in level1:

            for lvl2 in level2:

                mean_values = []
                std_values = []
                for lvl3 in level3:

                    filename = filedir + '/' + ip + '-' + lvl1 + '-' + lvl2 + '-' + lvl3 + '.log'

                    print(filename)
                    m, s = get_mean(filename)

                    if m != -1:
                        mean_values.append(m)
                        std_values.append(s)

                np.savetxt(f, (mean_values, std_values), fmt='%f',
                    delimiter=',', header=ip + '-' + lvl1 + '-' + lvl2 + '-')

    f.close()


#
# Normalize wrt a sequential time
#
def save_data_normal(outfilename, filedir, ip, tmsys, alloc, threads):

    f = open(outfilename, 'wb')


    # first process the sequential data
    filename = filedir + '/' + ip + '-' + 'seq-x86_64_nvm-ibmtcmalloc-1' + '.log'

    s_m, s_s = get_mean(filename)


    for tm in tmsys:

        for al in alloc:

            mean_values = []
            std_values = []
            for t in threads:

                filename = filedir + '/' + ip + '-' + tm + '-' + al + '-' + t + '.log'

                #print(filename)
                m, s = get_mean_normal(filename, s_m)

                if m != -1:
                    mean_values.append(m)
                    std_values.append(s)

            np.savetxt(f, (mean_values, std_values), fmt='%f',
                delimiter=',', header=ip + '-' + tm + '-' + al + '-')

    np.savetxt(f, (s_m, s_s), fmt='%f',
        delimiter=',', header=ip + '-' + 'seq-x86_64_nvm' + '-' + al + '-')

    f.close()


def save_data_compare(outfilename, versions, app, tm, alloc, thread):

    f = open(outfilename, 'wb')

    filedir = 'results-'
    for v in versions:

        mean_values = []
        std_values = []
        print(v)
        for t in threads:

            filename = filedir + v + '/logs/' + app + '-' + tm + '-' + alloc + '-' + t + '.log'

            m, s = get_mean(filename)

            if m != -1:
                mean_values.append(m)
                std_values.append(s)

        np.savetxt(f, (mean_values, std_values), fmt='%f',
              delimiter=',', header=app + '-' + v)

    f.close()



def save_data_compare(outfilename, versions, app, tm, alloc, thread):

    f = open(outfilename, 'wb')

    filedir = 'results-'
    for v in versions:

        mean_values = []
        std_values = []
        print(v)
        for t in threads:

            filename = filedir + v + '/logs/' + app + '-' + tm + '-' + alloc + '-' + t + '.log'

            m, s = get_mean(filename)

            if m != -1:
                mean_values.append(m)
                std_values.append(s)

        np.savetxt(f, (mean_values, std_values), fmt='%f',
              delimiter=',', header=app + '-' + v)

    f.close()





def save_data_time_fraction(outfilename, filedir, inprefix, level1, level2, level3):

    f = open(outfilename, 'wb')


    for ip in inprefix:

        for lvl1 in level1:

            for lvl2 in level2:

                for lvl3 in level3:  # threads

                    filename = filedir + '/' + ip + '-' + lvl1 + '-' + lvl2 + '-' + lvl3 + '.log'

                    time = []
                    hw = []
                    sw = []
                    lock = []
                    block = []

                    with open(filename) as fi:
                        for line in fi:
                            fields = line.strip().split()
                            if fields and fields[0] == 'Time' and fields[1] == '=':
                                time.append(float(fields[2]))
                            elif fields and fields[0] == 'hw:':
                                hw.append(float(fields[1]))
                            elif fields and fields[0] == 'sw:':
                                sw.append(float(fields[1]))
                            elif fields and fields[0] == 'lock:':
                                lock.append(float(fields[1]))
                            elif fields and fields[0] == 'TOTAL_TIME_B':
                                block.append(float(fields[3]))

                    time_mean, time_ci = get_mean_v(time)
                    hw_mean, hw_ci = get_mean_v(hw)
                    sw_mean, sw_ci = get_mean_v(sw)
                    lock_mean, lock_ci = get_mean_v(lock)
                    block_mean, block_ci = get_mean_v(block)

                    lis_mean = (block_mean/1000.0/int(lvl3)) /time_mean * 100
                    lis_percent = block_ci /block_mean
                    lis_ci = lis_mean * lis_percent

                    mean_values = []
                    ci_values = []
                    mean_values.append(hw_mean)
                    mean_values.append(sw_mean)
                    mean_values.append(lock_mean)
                    mean_values.append(lis_mean)

                    ci_values.append(hw_ci)
                    ci_values.append(sw_ci)
                    ci_values.append(lock_ci)
                    ci_values.append(lis_ci)

                    np.savetxt(f, (mean_values, ci_values), fmt='%f',
                        delimiter=',', header=ip + '-' + lvl1 + '-' + lvl2 +
                        '-' + lvl3 + ' [hw, sw, lock, lis]')

    f.close()



def save_data_transitions(outfilename, filedir, inprefix, level1, level2, level3):

    f = open(outfilename, 'wb')


    for ip in inprefix:

        for lvl1 in level1:

            for lvl2 in level2:

                for lvl3 in level3:  # threads

                    filename = filedir + '/' + ip + '-' + lvl1 + '-' + lvl2 + '-' + lvl3 + '.log'

                    hw_sw = []
                    hw_sw_cap = []
                    hw_sw_exp = []
                    hw_lock = []
                    hw_sw_time = []
                    sw_hw_time = []

                    with open(filename) as fi:
                        for line in fi:
                            fields = line.strip().split()
                            if fields and fields[0] == 'hw_sw_transitions:':
                                hw_sw.append(float(fields[1]))
                                hw_sw_cap.append(float(fields[4]))
                                hw_sw_exp.append(float(fields[7]))
                            elif fields and fields[0] == 'hw_lock_transitions:':
                                hw_lock.append(float(fields[1]))
                            elif fields and fields[0] == 'hw_sw_wtime:':
                                hw_sw_time.append(float(fields[3][:-1]))
                            elif fields and fields[0] == 'sw_hw_wtime:':
                                sw_hw_time.append(float(fields[3][:-1]))

                    hw_sw_mean, hw_sw_ci = get_mean_v(hw_sw)
                    hw_sw_cap_mean, hw_sw_cap_ci = get_mean_v(hw_sw_cap)
                    hw_sw_exp_mean, hw_sw_exp_ci = get_mean_v(hw_sw_exp)
                    hw_lock_mean, hw_lock_ci = get_mean_v(hw_lock)
                    hw_sw_time_mean, hw_sw_time_ci = get_mean_v(hw_sw_time)
                    sw_hw_time_mean, sw_hw_time_ci = get_mean_v(sw_hw_time)

                    mean_values = []
                    ci_values = []
                    mean_values.append(hw_sw_mean)
                    mean_values.append(hw_sw_cap_mean)
                    mean_values.append(hw_sw_exp_mean)
                    mean_values.append(hw_lock_mean)
                    mean_values.append(hw_sw_time_mean)
                    mean_values.append(sw_hw_time_mean)

#                    ci_values.append(time_ci)
                    ci_values.append(hw_sw_ci)
                    ci_values.append(hw_sw_cap_ci)
                    ci_values.append(hw_sw_exp_ci)
                    ci_values.append(hw_lock_ci)
                    ci_values.append(hw_sw_time_ci)
                    ci_values.append(sw_hw_time_ci)

                    np.savetxt(f, (mean_values, ci_values), fmt='%f',
                        delimiter=',', header=ip + '-' + lvl1 + '-' + lvl2 +
                        '-' + lvl3 + ' [hw->sw(all), hw->sw(cap), hw->sw(exp), hw->lock, hw->sw(time), sw->hw(time)]')

    f.close()





#
# Plots the graphs with execution times.
#
#
def plot_graphs():


    plotfolder = resultdir + '/' + exec_plot_dir + '/'
    if not os.path.exists(plotfolder):
        os.makedirs(plotfolder)

    tablefolder = resultdir + '/' + table_dir + '/'
    if not os.path.exists(tablefolder):
        os.makedirs(tablefolder)

    for b in benchmark:

        # table file name
        filename = tablefolder + b + '-time.csv'

        print('Processing ' + b)

        # save the table with execution time
        save_data(filename, resultdir+'/'+exec_log_dir, [b], tm,
                ['ibmtcmalloc'], threads)


        # read the data file
        values = np.genfromtxt(filename, delimiter=',')

        # a list of lists with execution time for each tm configuration
        listVal = []
        listErr = []

        # 1st row is time, 2nd row is stddev
        items = int(len(values)/2)

        # reads the values for each tm configuratoin
        for dr in range(items):
            bars1_v = []
            bars1_i = []
            for i in values[dr*2]:
                bars1_v.append(i)
            for i in values[dr*2+1]:
                bars1_i.append(i)


            listVal.append(bars1_v)
            listErr.append(bars1_i)

        fig, ax = plt.subplots()
        gap = .9 / len(listVal)
        for i, row in enumerate(listVal):
            X = np.arange(len(row))
            p = ax.bar(X + i * gap, row,
                width = gap,
                label = tmlabel[i],          # tm labels for the legend
                yerr=listErr[i],
                edgecolor = "black")

        ind = np.arange(len(threads))
        plt.xticks(ind + gap + 0.1, threads)


        plt.ylabel('Time (s)')
        plt.xlabel('Threads')
        plt.title(b.title())

        plt.minorticks_on()
        ax.tick_params(axis='x',which='minor',bottom=False)
        plt.grid(axis='y')
        plt.grid(b=True, which='major', axis='y', color='black', linestyle='dashed')

        fig = plt.gcf()
        fig.set_size_inches(15, 9)

        filename = plotfolder + b + '.pdf'
        plt.savefig(filename, bbox_inches = 'tight', pad_inches = 0)


#
# Plots the graphs normalizing to sequential execution.
#
#
def plot_graphs_normal():


    plotfolder = resultdir + '/' + exec_plot_dir + '/'
    if not os.path.exists(plotfolder):
        os.makedirs(plotfolder)

    tablefolder = resultdir + '/' + table_dir + '/'
    if not os.path.exists(tablefolder):
        os.makedirs(tablefolder)


    norm_list = []
    best_of = []
    for b in benchmark:

        # table file name
        filename = tablefolder + b + '-time-normal.csv'

        print('Processing ' + b)

        # save the table with execution time
        save_data_normal(filename, resultdir+'/'+exec_log_dir, b, tm,
                ['ibmtcmalloc'], threads)


        # read the data file
        # note that last two lines are skipped (seq values)
        values = np.genfromtxt(filename, delimiter=',', skip_footer=2)

        # a list of lists with execution time for each tm configuration
        listVal = []
        listErr = []

        # 1st row is time, 2nd row is stddev
        items = int(len(values)/2)

        # reads the values for each tm configuration
        for dr in range(items):
            bars1_v = []
            bars1_i = []
            for i in values[dr*2]:
                bars1.v.append(i)
            for i in values[dr*2+1]:
                bars1_i.append(i)


            listVal.append(bars1_v)
            listErr.append(bars1_i)

        norm_list.append(listVal)

        fig, ax = plt.subplots()
        gap = .8 / len(listVal)
        best_per_bench = []
        for i, row in enumerate(listVal):
            X = np.arange(len(row))
            p = ax.bar(X + i * gap, row,
                width = gap,
                label = tmlabel[i],          # tm labels for the legend
                yerr=listErr[i],
                edgecolor = "black")

            max_val = max(row)
            max_pos = row.index(max_val)
            best_per_bench.append((threads[max_pos], max_val))
        best_of.append(best_per_bench)

        ind = np.arange(len(threads))
        plt.xticks(ind + gap, threads)


        plt.ylabel('Speedup')
        plt.xlabel('Threads')
        #plt.title(b + ' (' + version + ')')
        plt.title(b.title())

        plt.minorticks_on()
        ax.tick_params(axis='x',which='minor',bottom=False)
        plt.grid(axis='y')
        plt.grid(b=True, which='major', axis='y', color='black', linestyle='dashed')

        fig = plt.gcf()
        fig.set_size_inches(15, 9)

        filename = plotfolder + 'speedup-' + b + '.pdf'
        plt.savefig(filename, bbox_inches = 'tight', pad_inches = 0)


    for b in range(len(benchmark)):
        print(benchmark[b], tmlabel)#, end = ' ')

        values = best_of[b]
        print(values)

    print('---')
    for s in range(len(tmlabel)):
        vals = []
        for b in range(len(benchmark)):
            vals.append(best_of[b][s][1])

        print(tmlabel[s], ': ', st.gmean(vals))


# calculate the geometric mean (of all benchs) for each thread number and tm
# system
    norm_vals = []
    for s in range(len(tm)):     # system

        per_sys = []
        for t in range(len(threads)):  # thread

            vals = []
            for b in range(len(benchmark)):     # benchmark
                vals.append(norm_list[b][s][t])

            per_sys.append(st.gmean(vals))

        norm_vals.append(per_sys)

    print('Normal values:')
    print(norm_vals)

# plot the graph
    fig, ax = plt.subplots()
    gap = .8 / len(norm_vals)
    global_normal = []
    for i, row in enumerate(norm_vals):
        print(tm[i])
        X = np.arange(len(row))
        p = ax.bar(X + i * gap, row,
            width = gap,
            label = tmlabel[i],          # tm labels for the legend
            edgecolor = "black")
        global_normal.append(st.gmean(row))

    print('Global normals: ', global_normal)

    ind = np.arange(len(threads))
    plt.xticks(ind + gap, threads)

    plt.ylabel('Speedup')
    plt.xlabel('Threads')
    plt.title('Geometric Mean (Speedups)')

    plt.minorticks_on()
    ax.tick_params(axis='x',which='minor',bottom=False)
    plt.grid(axis='y')
    plt.grid(b=True, which='major', axis='y', color='black', linestyle='dashed')

    fig = plt.gcf()
    fig.set_size_inches(15, 9)

    filename = plotfolder + 'geomean.pdf'
    plt.savefig(filename, bbox_inches = 'tight', pad_inches = 0)





def gen_tables():
    global tm

    tm = ['nvm_rtm-simple_lock', 'nvphtm_pstm_nh_x86_64', 'nvphtm_pstm_x86_64']

    tablefolder = resultdir + '/' + table_dir + '/'

    if not os.path.exists(tablefolder):
        os.makedirs(tablefolder)


    for b in benchmark:
        filename = tablefolder + b + '-phases.csv'

        print('Processing ' + b)

        save_data_time_fraction(filename, resultdir+'/'+exec_log_dir, [b], tm,
                ['ibmtcmalloc'], threads)


        pdfkit.from_file(filename,
                         filename+'.pdf')

        filename = tablefolder + b + '-transitions.csv'
        save_data_transitions(filename, resultdir+'/'+exec_log_dir, [b], tm,
                ['ibmtcmalloc'], threads)

        pdfkit.from_file(filename,
                         filename+'.pdf')




def plot_stagnation():


    stagfolder = resultdir + '/' + stag_plot_dir + '/'

    if not os.path.exists(stagfolder):
        os.makedirs(stagfolder)

    for backend in tm:

        for b in benchmark:

            print('Processing ' + b + ' with ' + backend)

            for t in threads:
                inputfile = resultdir + '/' + exec_log_dir + '/' + b + '-' + backend + '-ibmtcmalloc-'  + t + '.stag'

                xvaluesHW=[]
                xvaluesSW=[]
                valuesSR=[]
                valuesHWWR=[]
                valuesSWWR=[]
                valuesHWCyc=[]
                valuesSWCyc=[]
                with open(inputfile) as f:
                    for line in f:
                        fields = line.strip().split()
                        if fields and fields[0] == '---':
                            break

                        if fields:

                            if backend == 'pstm_x86_64':
                                xvaluesSW.append(int(fields[0]))
                                valuesSWWR.append(float(fields[1]))
                                valuesSWCyc.append(int(fields[2]))
                            else:
                                if fields[1] != '111': # hw
                                    xvaluesHW.append(int(fields[0]))
                                    valuesSR.append(int(fields[1]))
                                    valuesHWWR.append(float(fields[2]))
                                    valuesHWCyc.append(int(fields[3]))
                                else: # sw
                                    xvaluesSW.append(int(fields[0]))
                                    valuesSWWR.append(float(fields[2]))
                                    valuesSWCyc.append(int(fields[3]))

                fig, ax = plt.subplots()


                if backend == 'pstm_x86_64':
                    lns1 = ax.scatter(xvaluesSW, valuesSWWR, s=3, label='#writes(SW)', color='r')
                    ax.set_ylabel('Write rate')
                else:
                    lns1 = ax.scatter(xvaluesHW, valuesSR, s=3, label='Stagnation', color='r')

                    ax.set_ylabel('stagnation rate')

                ax.set_xlabel('time (cycles)')

                ax2 = ax.twinx()

                if backend == 'pstm_x86_64':
                    lns2 = ax2.scatter(xvaluesSW, valuesSWCyc, s=3, label='tx cycles(SW)', color='b')

                    ax2.set_ylabel('tx cycles')
                    outputfile = stagfolder + '/' + b + t + '-' + backend + '-wrcycles.png'
                else:
                    lns2 = ax2.scatter(xvaluesHW, valuesHWWR, s=3, label='#writes(HW)', color='b')

                    if backend == 'nvphtm_pstm_x86_64':
                        lns3 = ax2.scatter(xvaluesSW, valuesSWWR, s=3, label='#writes(SW)', color='g')

                    ax2.set_ylabel('#writes')
                    outputfile = stagfolder + '/' + b + t + '-' + backend + '-writeset-stagnation.png'

                fig.legend()

                plt.title(backend + '-' + b + '-' + t)


                fig = plt.gcf()
                fig.set_size_inches(15, 7)

                plt.savefig(outputfile, bbox_inches = 'tight', pad_inches = 0)
                plt.close()

                if backend == 'pstm_x86_64': continue


                fig, ax = plt.subplots()

                lns1 = ax.scatter(xvaluesHW, valuesSR, s=3, label='Stagnation', color='r')

                ax.set_ylabel('stagnation rate')
                ax.set_xlabel('time (cycles)')

                ax2 = ax.twinx()

                lns2 = ax2.scatter(xvaluesHW, valuesHWCyc, s=3, label='tx-cycles(HW)', color='b')

                if backend == 'nvphtm_pstm_x86_64':
                    lns3 = ax2.scatter(xvaluesSW, valuesSWCyc, s=3, label='tx-cycles(SW)', color='g')

                ax2.set_ylabel('Tx Cycles')

                fig.legend()

                plt.title(backend + '-' + b + '-' + t)

                fig = plt.gcf()
                fig.set_size_inches(15, 7)

                outputfile = stagfolder + '/' + b + t + '-' + backend + '-txcyles-stagnation.png'
                plt.savefig(outputfile, bbox_inches = 'tight', pad_inches = 0)
                plt.close()


#
# normalize pstm wrt nvm_rtm and plot the graphs considering write-set sizes
# and tx cycles
#
def normalize_graphs():

    stagfolder = resultdir + '/' + stag_plot_dir + '/'

    if not os.path.exists(stagfolder):
        os.makedirs(stagfolder)

    for b in benchmark:

        print('Normalizing ' + b)

        for t in threads:
            nvhtmfile = resultdir + '/' + exec_log_dir + '/' + b + '-nvm_rtm-simple_lock-ibmtcmalloc-'  + t + '.stag'
            pstmfile = resultdir + '/' + exec_log_dir + '/' + b + '-pstm_x86_64-ibmtcmalloc-'  + t + '.stag'

            # read nvhtm data
            xvaluesHW=[]
            valuesHWWR=[]
            valuesHWCyc=[]
            with open(nvhtmfile) as f:
                for line in f:
                    fields = line.strip().split()
                    if fields and fields[0] == '---':
                        break

                    if fields:
                        xvaluesHW.append(int(fields[0]))
                        valuesHWWR.append(float(fields[2]))
                        valuesHWCyc.append(int(fields[3]))

            # read pstm data
            xvaluesSW=[]
            valuesSWWR=[]
            valuesSWCyc=[]
            with open(pstmfile) as f:
                for line in f:
                    fields = line.strip().split()
                    if fields and fields[0] == '---':
                        break

                    if fields:
                        xvaluesSW.append(int(fields[0]))
                        valuesSWWR.append(float(fields[1]))
                        valuesSWCyc.append(int(fields[2]))


            fig, ax = plt.subplots()

            ax2 = ax.twinx()


            lns1 = ax.plot(xvaluesHW, valuesHWCyc, '.', label='Cycles (HW)', color='r')
            lns2 = ax.plot(xvaluesSW, valuesSWCyc, '.', label='Cycles (SW)', color='b')

            lns3 = ax2.plot(xvaluesSW, valuesSWWR, '.', label='#writes (SW)', color='g')

            ax.set_ylim(0,100000)
            ax2.set_ylim(0,20)

            ax.set_xlabel('time (HW cycles)')
            ax.set_ylabel('cycles')
            ax2.set_ylabel('#writes')

            fig.legend()

            plt.title(b + '-' + t)

            fig = plt.gcf()
            fig.set_size_inches(15, 7)

            outputfile = stagfolder + '/' + b + '-' + t + '.png'
            plt.savefig(outputfile, bbox_inches = 'tight', pad_inches = 0)
            plt.close()




def motivation():


    plotfolder = resultdir + '/' + exec_plot_dir + '/'
    if not os.path.exists(plotfolder):
        os.makedirs(plotfolder)

    tablefolder = resultdir + '/' + table_dir + '/'
    if not os.path.exists(tablefolder):
        os.makedirs(tablefolder)

    b = 'vacation'

    mt = ['1', '2', '4', '8', '12', '18']
    mtm = ['nvm_rtm-simple_lock', 'pstm_x86_64', 'nvphtm_pstm_x86_64']
    mtmlabel = ['NV-HTM', 'PSTM', 'NV-PhTM']

    filename = tablefolder + b + '-motivation.csv'

    # save the table with execution time
    save_data(filename, resultdir+'/'+exec_log_dir, [b], mtm,
            ['ibmtcmalloc'], mt)


    # read the data file
    values = np.genfromtxt(filename, delimiter=',')

    # a list of lists with execution time for each tm configuration
    listVal = []
    listErr = []

    # 1st row is time, 2nd row is stddev
    items = int(len(values)/2)

    # reads the values for each tm configuratoin
    for dr in range(items):
        bars1_v = []
        bars1_i = []
        for i in values[dr*2]:
            bars1_v.append(i)
        for i in values[dr*2+1]:
            bars1_i.append(i)


        listVal.append(bars1_v)
        listErr.append(bars1_i)

    fig, ax = plt.subplots()
    gap = .9 / len(listVal)
    for i, row in enumerate(listVal):
        X = np.arange(len(row))
        p = ax.bar(X + i * gap, row,
            width = gap,
            label = mtmlabel[i],          # tm labels for the legend
            yerr=listErr[i],
            edgecolor = "black")

    ax.legend()
    ind = np.arange(len(mt))
    plt.xticks(ind + gap + 0.1, mt)

    plt.ylabel('Time (s)')
    plt.xlabel('Threads')
    plt.title(b.title())

    plt.minorticks_on()
    ax.tick_params(axis='x',which='minor',bottom=False)
    plt.grid(axis='y')
    plt.grid(b=True, which='major', axis='y', color='black', linestyle='dashed')

    fig = plt.gcf()
    fig.set_size_inches(15, 9)

    filename = plotfolder + b + '-motivation.pdf'
    plt.savefig(filename, bbox_inches = 'tight', pad_inches = 0)



def plot_wset_cycles_stag():

    def thousands(x, pos):
        'The two args are the value and tick position'
        return '%1.0f' % (x * 1e-3)

    def millions(x, pos):
        'The two args are the value and tick position'
        return '%1.0f' % (x * 1e-6)

    SMALL_SIZE = 6+20
    MEDIUM_SIZE = 8+20
    BIGGER_SIZE = 10+10

    plt.rc('font', size=SMALL_SIZE)          # controls default text sizes
    plt.rc('axes', titlesize=SMALL_SIZE)     # fontsize of the axes title
    plt.rc('axes', labelsize=MEDIUM_SIZE)    # fontsize of the x and y labels
    plt.rc('xtick', labelsize=SMALL_SIZE)    # fontsize of the tick labels
    plt.rc('ytick', labelsize=SMALL_SIZE)    # fontsize of the tick labels
    plt.rc('legend', fontsize=SMALL_SIZE)    # legend fontsize
    plt.rc('figure', titlesize=BIGGER_SIZE)  # fontsize of the figure title

    version = '20191216-102228-2a499353ed'     # stagnation
    resultdir = 'results-' + version

    stagfolder = resultdir + '/' + stag_plot_dir + '/'

    if not os.path.exists(stagfolder):
        os.makedirs(stagfolder)

    b = 'intruder'

    t = '12'

    nvhtmfile = resultdir + '/' + exec_log_dir + '/' + b + '-nvm_rtm-simple_lock-ibmtcmalloc-'  + t + '.stag'
    pstmfile = resultdir + '/' + exec_log_dir + '/' + b + '-pstm_x86_64-ibmtcmalloc-'  + t + '.stag'

    # read nvhtm data
    xvaluesHW=[]
    valuesHWWR=[]
    valuesHWCyc=[]
    with open(nvhtmfile) as f:
        for line in f:
            fields = line.strip().split()
            if fields and fields[0] == '---':
                break

            if fields:
                xvaluesHW.append(int(fields[0]))
                valuesHWWR.append(float(fields[2]))
                valuesHWCyc.append(int(fields[3]))

    # read pstm data
    xvaluesSW=[]
    valuesSWWR=[]
    valuesSWCyc=[]
    with open(pstmfile) as f:
        for line in f:
            fields = line.strip().split()
            if fields and fields[0] == '---':
                break

            if fields:
                xvaluesSW.append(int(fields[0]))
                valuesSWWR.append(float(fields[1]))
                valuesSWCyc.append(int(fields[2]))


    fig, ax = plt.subplots()

    ax2 = ax.twinx()

    formatter = FuncFormatter(thousands)
    ax.yaxis.set_major_formatter(formatter)

    formatter = FuncFormatter(millions)
    ax.xaxis.set_major_formatter(formatter)

    lns1 = ax.plot(xvaluesHW, valuesHWCyc, '.', label='HW Tx Cycles', color='r')
    lns2 = ax.plot(xvaluesSW, valuesSWCyc, '.', label='SW Tx Cycles', color='b')
    lns3 = ax2.plot(xvaluesSW, valuesSWWR, '.', label='#Writes (SW)', color='g')# markersize=12)

    ax.set_ylim(0,70000)
    ax2.set_ylim(0,8)

    ax.set_xlabel('Time (processor cycles x $10^6$)')
    ax.set_ylabel('Transaction Length (cycles x $10^3$)')
    ax2.set_ylabel('Write-set Size')

    lgnd = fig.legend(loc=9, markerscale=5, ncol=3, frameon=False)

    fig = plt.gcf()
    fig.set_size_inches(15, 9)

    outputfile = stagfolder + '/heuristics-motivation.pdf'
    plt.savefig(outputfile, bbox_inches = 'tight', pad_inches = 0)
    plt.close()





if __name__ == '__main__':


    SMALL_SIZE = 6+30
    MEDIUM_SIZE = 8+30
    BIGGER_SIZE = 10+30

    plt.rc('font', size=SMALL_SIZE)          # controls default text sizes
    plt.rc('axes', titlesize=SMALL_SIZE)     # fontsize of the axes title
    plt.rc('axes', labelsize=MEDIUM_SIZE)    # fontsize of the x and y labels
    plt.rc('xtick', labelsize=SMALL_SIZE)    # fontsize of the tick labels
    plt.rc('ytick', labelsize=SMALL_SIZE)    # fontsize of the tick labels
    plt.rc('legend', fontsize=SMALL_SIZE)    # legend fontsize
    plt.rc('figure', titlesize=BIGGER_SIZE)  # fontsize of the figure title

    plt.rc('grid', linestyle='dashed', color='black')


#
# These are some methods that could be called - use it at your own risk
# plot_graphs_normal - this is the main function used in the paper
#


#    motivation()

#    plot_stagnation()
#    plot_wset_cycles_stag()

    plot_graphs_normal()
#    plot_graphs()
#    gen_tables()


#    benchmark = ['genome', 'intruder', 'kmeans', 'ssca2', 'vacation', 'yada']
#    normalize_graphs()


#=========================================================================

